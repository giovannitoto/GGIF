# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Update b_mu in the Adaptive Gibbs Sampler
#'
#' @param X A pxq matrix.
#' @param prec_mu A positive number.
#' @param prec_b A positive number.
#' @param mu A pxc matrix.
#' @param q An integer.
#' @param c An integer.
#'
#' @return A qxc matrix.
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
update_bmu <- function(X, prec_mu, prec_b, mu, q, c) {
    .Call(`_GGIF_update_bmu`, X, prec_mu, prec_b, mu, q, c)
}

#' Update the hth row of mu in the Adaptive Gibbs Sampler
#'
#' @param j An integer.
#' @param Qbet A cxc matrix.
#' @param W A nxc matrix.
#' @param Z_res A nxp matrix.
#' @param ps A p-dimensional vector.
#' @param b_mu A cxq matrix.
#' @param Xcov A pxq matrix.
#' @param c An integer.
#'
#' @return A 1xc matrix.
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
update_mu <- function(j, Qbet, W, Z_res, ps, b_mu, Xcov, c) {
    .Call(`_GGIF_update_mu`, j, Qbet, W, Z_res, ps, b_mu, Xcov, c)
}

#' Update eta in the Adaptive Gibbs Sampler
#'
#' @param Lambda A pxk matrix.
#' @param ps A p-dimensional vector.
#' @param k An integer.
#' @param Z A nxp matrix.
#' @param n An integer.
#'
#' @return A nxk matrix.
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
update_eta <- function(Lambda, ps, k, Z, n) {
    .Call(`_GGIF_update_eta`, Lambda, ps, k, Z, n)
}

#' Update the hth column of beta in the Adaptive Gibbs Sampler
#'
#' @param h An integer.
#' @param Xcov A pxq matrix.
#' @param Dt A pxk matrix.
#' @param Bh_1 A qxq matrix.
#' @param Phi_L A pxk matrix.
#' @param q An integer.
#'
#' @return A qx1 matrix.
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
update_beta <- function(h, Xcov, Dt, Bh_1, Phi_L, q) {
    .Call(`_GGIF_update_beta`, h, Xcov, Dt, Bh_1, Phi_L, q)
}

#' Update the jth row of Lambda_star in the Adaptive Gibbs Sampler
#'
#' @param j An integer.
#' @param etarho A kxn matrix.
#' @param Phi A pxk matrix.
#' @param Plam A kxk matrix.
#' @param ps A p-dimensional vector;
#' @param Z A nxp matrix.
#' @param k An integer.
#'
#' @return A 1xk matrix.
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
update_Lambda_star <- function(j, etarho, Phi, Plam, ps, Z, k) {
    .Call(`_GGIF_update_Lambda_star`, j, etarho, Phi, Plam, ps, Z, k)
}

#' Update the hth element of d in the Adaptive Gibbs Sampler
#'
#' @param h An integer.
#' @param Phi A pxk matrix.
#' @param p An integer.
#' @param n An integer.
#' @param rho A k-dimensional vector.
#' @param eta A nxk matrix.
#' @param lambdastar A pxk matrix.
#' @param Z A nxp matrix.
#' @param sdy A nxp matrix.
#' @param k An integer.
#' @param w A k-dimensional vector.
#'
#' @return An integer in 1, ..., k.
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
update_d <- function(h, Phi, p, n, rho, eta, lambdastar, Z, sdy, k, w) {
    .Call(`_GGIF_update_d`, h, Phi, p, n, rho, eta, lambdastar, Z, sdy, k, w)
}

#' Update Phi in the Adaptive Gibbs Sampler
#'
#' @param rho A k-dimensional vector.
#' @param logit A pxk matrix.
#' @param p_constant A number in (0,1).
#' @param p An integer.
#' @param n An integer.
#' @param eta A nxk matrix.
#' @param lambdastar A pxk matrix.
#' @param Phi A pxk matrix.
#' @param Z A nxp matrix.
#' @param sdy A nxp matrix.
#' @param k An integer.
#'
#' @return A pxk matrix.
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
update_Phi <- function(rho, logit, p_constant, p, n, eta, lambdastar, Phi, Z, sdy, k) {
    .Call(`_GGIF_update_Phi`, rho, logit, p_constant, p, n, eta, lambdastar, Phi, Z, sdy, k)
}

#' Sample from a truncated normal distribution. Samples are drawn
#' componentwise, so each component of the vector is allowed its own
#' mean, standard deviation, and upper and lower limits. The components
#' are assumed to be independent.
#'
#' @param y_lower \code{n x p} matrix of lower endpoints
#' @param y_upper \code{n x p} matrix of upper endpoints
#' @param mu \code{n x p} matrix of conditional expectations
#' @param sigma \code{p x 1} vector of conditional standard deviations
#' @param u_rand \code{n x p} matrix of uniform random variables
#'
#' @return z_star \code{n x p} draw from the truncated normal distribution
#'
#' @note This function uses \code{Rcpp} for computational efficiency.
#'
truncnorm_lg <- function(y_lower, y_upper, mu, sigma, u_rand) {
    .Call(`_GGIF_truncnorm_lg`, y_lower, y_upper, mu, sigma, u_rand)
}

